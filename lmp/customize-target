#!/usr/bin/python3
#
# Copyright (c) 2019 Foundries.io
# SPDX-License-Identifier: Apache-2.0
#
import argparse
import logging
import json
import os
import subprocess
import urllib.request

from copy import deepcopy

logging.basicConfig(level='INFO')
fh = logging.FileHandler('/archive/customize-target.log')
fh.setFormatter(logging.getLogger().handlers[0].formatter)
logging.getLogger().addHandler(fh)


class TagMgr:
    def __init__(self):
        # Convert thinkgs like:
        #    tag1,tag2 -> [(tag1, tag1), (tag2, tag2)]
        #    tag1:blah,tag2 -> [(tag1, blah), (tag2, tag2)]
        self._tags = []
        for x in (os.environ.get('OTA_LITE_TAG') or '').split(','):
            parts = x.strip().split(':', 1)
            if len(parts) == 1 or parts[1] == '':
                self._tags.append((parts[0], parts[0]))
            else:
                self._tags.append((parts[0], parts[1]))

    def __repr__(self):
        return str(self._tags)

    @property
    def tags(self):
        return self._tags


def git_hash(gitdir):
    return subprocess.check_output(
        ['git', 'log', '-1', '--format=%H'], cwd=gitdir
    ).strip().decode()


def targets_from_api():
    """ When we are called to create the installed_targets file, we'll
    We need to get the targets from the API so that we can help find the
       current docker-apps.
    """
    url = 'https://api.foundries.io/ota/repo/'
    url += os.environ['FOUNDRIES_FACTORY']
    url += '/api/v1/user_repo/targets.json'
    try:
        with open('/secrets/osftok') as f:
            token = f.read().strip()
    except FileNotFoundError:
        logging.warning('osftok not found, assuming a simulator build')
        return {}

    req = urllib.request.Request(url, headers={'OSF-TOKEN': token})
    with urllib.request.urlopen(req) as response:
        data = json.load(response)
        return data['signed']['targets']


def merge(args):
    with open(args.targets_json) as f:
        data = json.load(f)

    changed = False

    try:
        targets = data['targets']
    except KeyError:
        logging.info('Assuming installed_versions file')
        # have a dict: ostree-hash: target-name, convert to a target
        name, version = args.target_name.rsplit('-', 1)
        machine, _ = name.split('-lmp', 1)
        data = {
            v: {
                'hashes': {'sha256': k},
                'is_current': True,
                'custom': {
                    'targetFormat': 'OSTREE',
                    'name': name,
                    'version': version,
                    'hardwareIds': [machine],
                }
            } for k, v in data.items()
        }
        targets = targets_from_api()
        targets.update(data)
        changed = True

    tagmgr = TagMgr()
    logging.info('Target is: %r', targets[args.target_name])
    logging.info('Doing Target tagging for: %s', tagmgr)

    updates = []
    for idx, (tgt_tag, apps_tag) in enumerate(tagmgr.tags):
        tgt = targets[args.target_name]
        tgt['custom']['lmp-manifest-sha'] = git_hash('/srv/oe/.repo/manifests')
        try:
            tgt['custom']['meta-subscriber-overrides-sha'] = git_hash(
                '/srv/oe/layers/meta-subscriber-overrides')
        except Exception:
            pass  # okay - LMP build doesn't have this repo
        if idx:
            tgt = deepcopy(tgt)
            targets[args.target_name + '-%d' % idx] = tgt
            changed = True
        if tgt_tag:
            tgt['custom']['tags'] = [tgt_tag]
            changed = True
        updates.append({
            'ver': int(tgt['custom']['version']),
            'tag': apps_tag,
            'tgt': tgt,
            'prev': None,
        })

    # Now find the previous version of each target
    for tgt in targets.values():
        for cur in updates:
            if tgt['custom'].get('name') == cur['tgt']['custom']['name']:
                tag = cur['tag']
                match_tag = not tag or tag in tgt['custom'].get('tags', [])
                tgt_ver = int(tgt['custom']['version'])
                prev_ver = 0
                if cur['prev']:
                    prev_ver = int(cur['prev']['custom']['version'])
                if match_tag and tgt_ver > prev_ver and tgt_ver < cur['ver']:
                    cur['prev'] = tgt

    for u in updates:
        if u['prev']:
            logging.info('Prev is: %r', u['prev'])
            apps = u['prev']['custom'].get('docker_apps')
            if apps:
                logging.info('Updating build to have apps: %r', apps)
                u['tgt']['custom']['docker_apps'] = apps
                sha = u['prev']['custom'].get('containers-sha')
                if sha:
                    u['tgt']['custom']['containers-sha'] = sha
                changed = True
            apps = u['prev']['custom'].get('docker_compose_apps')
            if apps:
                logging.info('Updating build to have compose apps: %r', apps)
                u['tgt']['custom']['docker_compose_apps'] = apps
                sha = u['prev']['custom'].get('containers-sha')
                if sha:
                    u['tgt']['custom']['containers-sha'] = sha
                changed = True

    if changed:
        logging.info('Target has changed, saving changes')
        with open(args.targets_json, 'w') as f:
            json.dump(data, f, indent=2)


def get_args():
    parser = argparse.ArgumentParser(
        '''Do LMP customiziations of the current build target. Including
           copying docker apps defined in the previous build target.''')

    parser.add_argument('targets_json')
    parser.add_argument('target_name')

    return parser.parse_args()


if __name__ == '__main__':
    args = get_args()
    merge(args)
