#!/usr/bin/python3
#
# Copyright (c) 2019 Foundries.io
# SPDX-License-Identifier: Apache-2.0
#
import subprocess
import os
import json
import argparse
import logging
import tempfile
import base64

from helpers import http_get
from compose_app_downloader import dump_app_images


logger = logging.getLogger("System Image Assembler")
wic_tool = None


def _get_targets_from_api(factory: str, token: str):
    api_base_url = 'https://api.foundries.io/ota/repo/'
    targets_endpoint = 'api/v1/user_repo/targets.json'

    target_url = os.path.join(api_base_url, factory, targets_endpoint)
    target_resp = http_get(target_url, headers={'OSF-TOKEN': token})
    return target_resp.json()['signed']['targets']


def get_targets_from_api_by_build_numb(factory: str, build_num: str, token: str):
    logger.info('Fetching factory targets; Factory: {}, version: {}'.format(factory, build_num))
    targets = _get_targets_from_api(factory, token)
    res_targets = {}

    for target_name, target in targets.items():
        custom = target.get('custom')
        if not custom:
            continue

        if custom.get('version', '') == build_num and custom.get('targetFormat', 'NONE') == 'OSTREE':
            res_targets[target_name] = target
    return res_targets


def get_targets_from_api_by_targets(factory: str, target_names: list, token: str):
    logger.info('Fetching factory targets; Factory: {}, Targets: {}'.format(factory, target_names))
    targets = _get_targets_from_api(factory, token)
    res_targets = {}
    for target_name in target_names:
        if target_name in targets:
            res_targets[target_name] = targets[target_name]
    return res_targets


def get_system_image_from_ci(target: dict, token: str):
    # https://api.foundries.io/projects/<factory>/lmp/builds/<build-numb>/runs/<machine>/<image-name>-<machine>.wic.gz

    image_base_url = target['custom']['uri']
    image_machine = target['custom']['hardwareIds'][0]
    image_filename = target['custom']['image-file']

    base_url = image_base_url.replace('ci.foundries.io', 'api.foundries.io')
    image_url = os.path.join(base_url, 'runs', image_machine, image_filename)

    logger.info('Fetching {}...\n'.format(image_url))

    image_resp = http_get(image_url, headers={'OSF-TOKEN': token})
    with open(image_filename, 'wb') as image_file:
        for data_chunk in image_resp.iter_content(chunk_size=65536):
            image_file.write(data_chunk)

    subprocess.check_call(['gunzip', '-f', image_filename])
    return image_filename.rstrip('.gz')


def get_registry_jwt_token(registry_oauth_token, factory, repo, hub_creds):
    user_pass = '{}:{}'.format(hub_creds['Username'], hub_creds['Secret'])

    headers = {
        'Authorization': 'Basic ' + base64.b64encode(user_pass.encode()).decode()
    }

    params = {
        'service': 'registry',
        'scope': 'repository:{}/{}:pull'.format(factory, repo)
    }

    token_req = http_get(registry_oauth_token, headers=headers, params=params)
    return token_req.json()


def download_target_app(target: dict, token: str, app_root_dir: str):
    for app, app_desc in target['custom']['docker_compose_apps'].items():
        logger.info('Downloading Compose App {}...'.format(app))
        uri = app_desc['uri']
        uri_parts = uri.split('@')
        registry_host, factory, app = uri_parts[0].split('/')
        digest = uri_parts[1]

        registry_jwt_token = get_registry_jwt_token('https://hub.foundries.io/token-auth/', factory, app,
                                                    {'Username': 'ci-job', 'Secret': token})

        manifest_url = 'https://{}/v2/{}/{}/manifests/{}'.format(registry_host, factory, app, digest)
        logger.info('Pulling App manifest: {}'.format(manifest_url))
        manifest_resp = http_get(manifest_url,
                                     headers={'authorization': 'bearer {}'.format(registry_jwt_token['token']),
                                              'accept': 'application/vnd.oci.image.manifest.v1+json'})
        manifest = json.loads(manifest_resp.content)
        logger.info('Got App manifest')

        app_url = 'https://{}/v2/{}/{}/blobs/{}'.format(registry_host, factory, app, manifest['layers'][0]['digest'])
        logger.info('Pulling App archive: {}'.format(app_url))
        archive_resp = http_get(app_url, headers={'authorization': 'bearer {}'.format(registry_jwt_token['token'])})
        app_archive_file = os.path.join(app_root_dir, app + '.tgz')
        with open(app_archive_file, 'wb') as app_tgz:
            app_tgz.write(archive_resp.content)

        logger.info('Got {}'.format(app_archive_file))
        app_dir = os.path.join(app_root_dir, app)
        os.makedirs(app_dir, exist_ok=True)
        subprocess.check_call(['tar', '-xzf', app_archive_file, '-C', app_dir])
        logger.info('Compose App {} has been downloaded and extracted to {}'.format(app, app_dir))


def login_at_docker_registry(token, registry_host='hub.foundries.io'):
    login_process = subprocess.Popen(
        ['docker', 'login', registry_host, '--username=doesntmatter', '--password-stdin'],
        stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)

    output = login_process.communicate(input=token.encode())[0]
    # this is kind of useless verification because login at hub.foundries.io is successful
    # for any value of username and/or password
    if -1 == (str(output)).find('Login Succeeded'):
        raise Exception('Failed to login at {}'.format('hub.foundries.io'))


def dump_apps_container_images(target: dict, containers_arch: str, app_image_tar: str, token: str):
    login_at_docker_registry(token)
    with tempfile.TemporaryDirectory() as tmp_docker_dir:
        with tempfile.TemporaryDirectory() as tmp_app_dir:
            download_target_app(target, token, tmp_app_dir)
            dump_app_images(tmp_app_dir, [containers_arch], tmp_docker_dir)
            subprocess.check_call(['tar', '-cf', app_image_tar,
                                   '-C', os.path.join(tmp_docker_dir, containers_arch), '.'])


def copy_container_images_to_wic(target: dict, app_image_dir: str, wic_image: str, token: str):
    partition = '2'
    directory = '/ostree/deploy/lmp/var/sota/import/'

    containers_sha = target['custom']['containers-sha']
    arch_map = {'aarch64': 'arm64', 'x86_64': 'amd64', 'arm': 'arm'}
    containers_arch = arch_map[target['custom']['arch']]

    app_image_tar_src = os.path.join(app_image_dir, containers_sha, '{}-{}.tar'.format(containers_sha, containers_arch))
    if not os.path.exists(app_image_tar_src):
        logger.info('Container images have not been found, trying to obtain them...')
        os.makedirs(os.path.dirname(app_image_tar_src), exist_ok=True)
        dump_apps_container_images(target, containers_arch, app_image_tar_src, token)

    # There is no guarantee that in the case of a `dump_apps_container_images` failure
    # an exception or exit() will be called (some rough edge cases).
    # Moreover, the following call `subprocess.check_call([wic_tool, 'cp', app_image_tar_src, app_image_tar_dst])`
    # does not raise any exception if `app_image_tar_src` doesn't exist
    # Therefore, in order to detect such subtle/silent error the following check is enabled,
    # it just throws an exception if the tar file does not exist prior to injecting it to the target wic file.

    if not os.path.exists(app_image_tar_src):
        raise Exception('Container images archive {} has not been obtained'.format(app_image_tar_src))

    app_image_tar_dst = '{}:{}{}'.format(wic_image, partition, directory)

    logger.info('Copying container images of Target apps to its WIC image: {} --> {}'
                .format(app_image_tar_src, app_image_tar_dst))
    subprocess.check_call([wic_tool, 'cp', app_image_tar_src, app_image_tar_dst])


def update_installed_versions_on_wic_image(target_name: str, target: str, wic_image: str):
    installed_versions_filename = 'installed_versions'
    old_installed_versions_filename = 'installed_versions.old'
    partition = '2'
    installed_versions_in_wic_image = '/ostree/deploy/lmp/var/sota/import/' + installed_versions_filename

    target['is_current'] = True
    installed_versions = {target_name: target}

    with open(installed_versions_filename, 'w') as installed_versions_file:
        json.dump(installed_versions, installed_versions_file, indent=2)

    installed_versions_dst_path = '{}:{}{}'.format(wic_image, partition, installed_versions_in_wic_image)
    subprocess.check_call([wic_tool, 'cp', installed_versions_dst_path, old_installed_versions_filename])

    with open(old_installed_versions_filename, 'r') as f:
        old_version = json.load(f)

    logger.info('Updating `installed_versions` for the given system image\n')
    logger.info('From\n{}'.format(json.dumps(old_version, ensure_ascii=True, indent=2)))
    logger.info('To\n{}'.format(json.dumps(installed_versions, ensure_ascii=True, indent=2)))

    subprocess.check_call([wic_tool, 'rm', installed_versions_dst_path])
    subprocess.check_call([wic_tool, 'cp', installed_versions_filename, installed_versions_dst_path])


def archive_and_output_assembled_wic(wic_image: str, out_image_dir: str):
    logger.info('Gzip and move resultant WIC image to the specified destination folder: {}'.format(out_image_dir))
    os.makedirs(out_image_dir, exist_ok=True)
    subprocess.check_call(['gzip', wic_image])
    subprocess.check_call(['mv', wic_image + '.gz', out_image_dir])


def assemble_image_for_targets(targets: dict, app_image_dir: str, out_image_dir: str, token: str):
    for target_name, target in targets.items():
        logger.info('Got Target {}, processing it...'.format(target_name))
        wic_image = get_system_image_from_ci(target, token)
        copy_container_images_to_wic(target, app_image_dir, wic_image, token)
        update_installed_versions_on_wic_image(target_name, target, wic_image)
        archive_and_output_assembled_wic(wic_image, out_image_dir)


def get_args():
    parser = argparse.ArgumentParser('''Add container images to a system image''')

    parser.add_argument('-f', '--factory', help='Factory', default=os.environ.get('FACTORY'))
    parser.add_argument('-b', '--build-num', help='Build number', default=os.environ.get('H_BUILD'))
    parser.add_argument('-t', '--token-file', help='A file containing OSF token',
                        default=os.environ.get('TOKEN_FILE', '/secrets/osftok'))
    parser.add_argument('-w', '--wic-tool', help='A path to WIC utility', default=os.environ.get('WIC_TOOL'))
    parser.add_argument('-a', '--app-image-dir', help='A path to directory that contains app container images',
                        default=os.environ.get('APP_IMAGE_DIR'))
    parser.add_argument('-o', '--out-image-dir', help='A path to directory to put a resultant image to',
                        default=os.environ.get('OUT_IMAGE_DIR'))

    parser.add_argument('-T', '--targets', help='A coma separated list of Targets to assemble system image for',
                        default=os.environ.get('TARGETS'))

    args = parser.parse_args()

    if args.factory is None:
        logger.error('Argument `Factory` is missing, specify it either as a command line argument'
                     ' or a FACTORY environment variable')
        parser.print_help()
        exit(1)

    if args.build_num is None and args.targets is None:
        logger.error('Both arguments `Build number` and `TARGETS` are missing, '
                     'specify one of them either as a command line argument or an H_BUILD environment variable')
        parser.print_help()
        exit(1)

    if args.targets:
        args.targets = args.targets.split(',')

    if args.token_file is None:
        logger.error('Argument `Token file` is missing, specify it either as a command line argument'
                     ' or a TOKEN_FILE environment variable')
        parser.print_help()
        exit(1)

    else:
        with open(args.token_file) as token_file:
            vars(args)['token'] = token_file.read().strip()

    if args.wic_tool is None:
        logger.error('Argument `WIC tool` is missing, specify it either as a command line argument'
                     ' or a WIC_TOOL environment variable')
        parser.print_help()
        exit(1)

    if args.app_image_dir is None:
        logger.error('Argument `App Image Dir` is missing, specify it either as a command line argument'
                     ' or a APP_IMAGE_DIR environment variable')
        parser.print_help()
        exit(1)

    if args.out_image_dir is None:
        logger.error('Argument `Out Image Dir` is missing, specify it either as a command line argument'
                     ' or a OUT_IMAGE_DIR environment variable')
        parser.print_help()
        exit(1)

    return args


if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO)
    args = get_args()
    wic_tool = args.wic_tool

    try:
        if args.targets:
            targets = get_targets_from_api_by_targets(args.factory, args.targets, args.token)
            err_msg = 'No Targets found; Factory: {}, input Target list: {}'.format(args.factory, args.targets)
        else:
            targets = get_targets_from_api_by_build_numb(args.factory, str(args.build_num), args.token)
            err_msg = 'No Targets found; Factory: {}, Version/Build Number: {}'.format(args.factory, args.build_num)

        if len(targets) == 0:
            logger.warning(err_msg)
            exit(1)

        assemble_image_for_targets(targets, args.app_image_dir, args.out_image_dir, args.token)
    except Exception as exc:
        logger.error("Failed to assemble a system image(s): " + str(exc))
